'use strict';

// Реализовать базовые классы игры: Vector, Actor и Level.

// Класс `Vector`, который позволит контролировать расположение объектов в двумерном пространстве и управлять их размером и перемещением

class Vector {    
  constructor(x = 0, y = 0) { // Координаты по оси X и по оси Y 
    this.x = x;
    this.y = y;
  }
  
  // Метод `plus` - Создает и возвращает новый объект типа Vector, с новыми координатами
  plus(vector) {
    if (!(vector instanceof Vector)) {
      throw new Error(`Можно прибавлять к вектору только вектор типа Vector`);
    }
    return new Vector(this.x + vector.x, this.y + vector.y);
  }

  // Метод `times` - Создает и возвращает новый объект типа Vector, с новыми координатами
  times(num) {
    return new Vector(this.x * num, this.y * num);
  }
} // Vector

// Движущийся объект
// Класс Actor, который позволит контролировать все движущиеся объекты на игровом поле и контролировать их пересечение.

class Actor {
  constructor(pos = new Vector(0, 0), size = new Vector(1, 1), speed = new Vector(0, 0)) {		
	if ( !(pos instanceof Vector) || !(size instanceof Vector) || !(speed instanceof Vector) ) {
	  throw new Error('Объект не является объектом типа Vector')			
	}
	this.pos = pos;
	this.size = size;
	this.speed = speed;		
  }
  
  act() {}  // Метод act, который ничего не делает
	
  // Должны быть определены свойства только для чтения left, top, right, bottom, в которых установлены границы объекта по осям X и Y с учетом его расположения и размера.
  get left() {  // границы объекта по X
    return this.pos.x;
  }  

  get right() {  // границы объекта по X + размер
	return this.pos.x + this.size.x;
  }
	
  get top() {  // границы объекта по Y
	return this.pos.y;
  }
	
  get bottom() {  // границы объекта по Y + размер
	return this.pos.y + this.size.y;
  }
	
  // Должен иметь свойство type — строку со значением actor, только для чтения.
  get type() {
	return 'actor';
  }	
	
  /* Метод isIntersect
	Метод проверяет, пересекается ли текущий объект с переданным объектом, и если да, возвращает true, иначе – false.
	Принимает один аргумент — движущийся объект типа Actor. 
	Если передать аргумент другого типа или вызвать без аргументов, то метод бросает исключение.
	Если передать в качестве аргумента этот же объект, то всегда возвращает false. 
	Объект не пересекается сам с собой. Объекты, имеющие смежные границы, не пересекаются.
  */

  isIntersect(actor) {
	if (!actor || !(actor instanceof Actor)) {
	  throw new Error('Объект не существует или не является объектом класса Actor')
	}
	if (actor === this) {
	  return false;
	}
	return this.left < actor.right && 
	       this.right > actor.left &&
	       this.top < actor.bottom &&
	       this.bottom > actor.top;	
  }  
} // Actor

/* Игровое поле
Объекты класса Level реализуют схему игрового поля конкретного уровня, контролируют все движущиеся объекты на нём и реализуют логику игры. Уровень представляет собой координатное поле, имеющее фиксированную ширину и высоту.

Сетка уровня представляет собой координатное двумерное поле, представленное двумерным массивом. Первый массив — строки игрового поля; индекс этого массива соответствует координате Y на игровом поле. Элемент с индексом 5 соответствует строке с координатой Y, равной 5. Вложенные массивы, расположенные в элементах массива строк, представляют ячейки поля. Индекс этих массивов соответствует координате X. Например, элемент с индексом 10, соответствует ячейке с координатой X, равной 10.

Так как grid — это двумерный массив, представляющий сетку игрового поля, то, чтобы узнать, что находится в ячейке с координатами X=10 и Y=5 (10:5), необходимо получить значение grid[5][10]. Если значение этого элемента равно undefined, то эта ячейка пуста. Иначе там будет строка, описывающая препятствие. Например, wall — для стены и lava — для лавы. Отсюда вытекает следующий факт: все препятствия имеют целочисленные размеры и координаты.
*/

// grid[] - сетка игрового поля, actors[]- список движущихся объектов игрового поля

class Level {	
  constructor(grid = [], actors = []) {  
	this.grid = grid;  
	this.actors = actors;
	this.player = actors.find(actor => actor.type === 'player'); 	  
	this.status = null;  // состояние прохождения уровня
	this.finishDelay = 1;  //таймаут после окончания игры
	this.height = grid.length;  // высота = длине массива
	this.width = grid.reduce(((max, arr) => (arr.length > max) ? arr.length : max), 0);
	  
  	/* Свойства
   	Имеет свойство `grid` — сетку игрового поля. Двумерный массив строк.
   	Имеет свойство `actors` — список движущихся объектов игрового поля, массив объектов `Actor`.
   	Имеет свойство `player` — движущийся объект, тип которого — свойство `type` — равно `player`. 
		             Игорок передаётся с остальными движущимися объектами.   		
   	Имеет свойство `status` — состояние прохождения уровня, равное `null` после создания.
   	Имеет свойство `finishDelay` — таймаут после окончания игры, равен `1` после создания. 
		             Необходим, чтобы после выигрыша или проигрыша игра не завершалась мгновенно.
    Имеет свойство `height` — высоту игрового поля, равное числу строк в сетке из первого аргумента.
   	Имеет свойство `width` — ширину игрового поля, равное числу ячеек в строке сетки из первого аргумента. 
					При этом, если в разных строках разное число ячеек, 
					то `width` будет равно максимальному количеству ячеек в строке. */
	  
  }		
	
  	/* Метод `isFinished`
  	Определяет, завершен ли уровень. Не принимает аргументов.
	Возвращает `true`, если свойство `status` не равно `null` и `finishDelay` меньше нуля.
  	*/
	
  isFinished() { // Определяет, завершен ли уровень
	return (this.status !== null) && (this.finishDelay < 0) ? true : false;
  }
	
	/* Метод `actorAt`
  	Определяет, расположен ли какой-то другой движущийся объект в переданной позиции, и если да, вернёт этот объект.
  	Принимает один аргумент — движущийся объект, `Actor`. 
	Если не передать аргумент или передать не объект `Actor`, метод должен бросить исключение.
  	Возвращает `undefined`, если переданный движущийся объект не пересекается ни с одним объектом на игровом поле.
  	Возвращает объект `Actor`, если переданный объект пересекается с ним на игровом поле. Если пересекается с несколькими объектами, вернет первый.
	*/
	
  actorAt(actor) {  // Определяет, расположен ли какой-то другой движущийся объект в переданной позиции
    if (!actor || !(actor instanceof Actor))  {
	  throw new Error('Объект не существует или не является объектом класса Actor')	  
	}
    return this.actors.find(obj => obj.isIntersect(actor));
  }
  
	/* Метод `obstacleAt`
	Аналогично методу `actorAt` определяет, нет ли препятствия в указанном месте. 
	Также этот метод контролирует выход объекта за границы игрового поля.
	Так как движущиеся объекты не могут двигаться сквозь стены, то метод принимает два аргумента: 
		положение, куда собираемся передвинуть объект, _вектор_ `Vector`, и 
		размер этого объекта, тоже _вектор_ `Vector`. 
	Если первым и вторым аргументом передать не `Vector`, то метод бросает исключение.
	
	Вернет строку, соответствующую препятствию из сетки игрового поля, пересекающему область, описанную двумя переданными векторами, либо `undefined`, если в этой области препятствий нет.
	Если описанная двумя векторами область выходит за пределы игрового поля, то метод вернет строку `lava`, если область выступает снизу. И вернет `wall` в остальных случаях. Будем считать, что игровое поле слева, сверху и справа огорожено стеной и снизу у него смертельная лава.
	*/	

  obstacleAt(pos, size)  {  // определяет, нет ли препятствия в указанном месте
	if ( !(pos instanceof Vector) || !(size instanceof Vector) ) {
	  throw new Error('Объект не существует или не является объектом класса Vector');
	}
	const borderLeft = Math.floor(pos.x);
	const borderTop = Math.floor(pos.y);
	const borderRight = Math.ceil(pos.x + size.x);
	const borderBottom = Math.ceil(pos.y + size.y);					
					
	//Если описанная двумя векторами область выходит за пределы игрового поля, 
	//то метод вернет строку lava, если область выступает снизу. 
	//И вернет wall в остальных случаях. Будем считать, что игровое поле слева, 
	//сверху и справа огорожено стеной и снизу у него смертельная лава.
	  
	if (borderBottom > this.height)  {
	  return 'lava';
	}
	  
	if (borderLeft < 0 || borderTop < 0 || borderRight > this.width) {
	  return 'wall';
	}
	
	// Вернет строку, соответствующую препятствию из сетки игрового поля, пересекающему область, 
	// описанную двумя переданными векторами, либо `undefined`, если в этой области препятствий нет.
	for (let y = borderTop; y < borderBottom; y++) {
	  for (let x = borderLeft; x < borderRight; x++) {
		const gridLevel = this.grid[y][x];
		if (gridLevel) {
		  return gridLevel;
		}
	  }
	}		
  }
	
	/* Метод `removeActor`
   	  Метод удаляет переданный объект с игрового поля. Если такого объекта на игровом поле нет, не делает ничего.
   	  Принимает один аргумент, объект `Actor`. Находит и удаляет его.
	*/
	
  removeActor(actor) {  // удаляет переданный объект с игрового поля
	const indexActor = this.actors.indexOf(actor);  // находим индекс объекта
	if (indexActor !== -1) {
	  this.actors.splice(indexActor, 1); // удаляем 
	}
  }
	
  /* Метод `noMoreActors`
  Определяет, остались ли еще объекты переданного типа на игровом поле.
  Принимает один аргумент — тип движущегося объекта, _строка_.
  Возвращает `true`, если на игровом поле нет объектов этого типа (свойство `type`). Иначе возвращает `false`.
  */
  noMoreActors(type) {  // Определяет, остались ли еще объекты переданного типа на игровом поле.
	if (this.actors.find(obj => obj.type === type)) {
	  return false;
	}
	return true;
  }
	
	/* Метод `playerTouched`
	 Один из ключевых методов, определяющий логику игры. Меняет состояние игрового поля при касании игроком каких-либо объектов или препятствий.
	 Если состояние игры уже отлично от `null`, то не делаем ничего, игра уже и так завершилась.
	 Принимает два аргумента. Тип препятствия или объекта, _строка_. Движущийся объект, которого коснулся игрок, — объект типа `Actor`, необязательный аргумент.
	 Если первым аргументом передать строку `lava` или `fireball`, то меняем статус игры на `lost` (свойство `status`). Игрок проигрывает при касании лавы или шаровой молнии.
	 Если первым аргументом передать строку `coin`, а вторым — объект монеты, то необходимо удалить эту монету с игрового поля. Если при этом на игровом поле не осталось больше монет, то меняем статус игры на `won`. Игрок побеждает, когда собирает все монеты на уровне. Отсюда вытекает факт, что уровень без монет пройти невозможно.
	 */
	
  playerTouched(type, actor) { // определяет логику игры, меняет состояние игрового поля при касании объектов
	if (this.status !== null) {
	  return;
	} 
	if (type === 'lava' || type === 'fireball') {
	  return this.status = 'lost';  // Игрок проигрывает
	}
	if (type === 'coin' && actor.type === 'coin') { // если коснулись монеты
	  this.removeActor(actor);	// необходимо удалить эту монету
	}
	if (this.noMoreActors('coin')) { // если монет больше нет
	  return this.status = 'won';  // Игрок побеждает
	}
  }	
} //level
	
/* Парсер уровня
Объект класса`LevelParser` позволяет создать игровое поле`Level` из массива строк по следующему принципу:
	* Каждый элемент массива соответствует строке в сетке уровня.
	* Каждый символ строки соответствует ячейке в сетке уровня.
	* Символ определяет тип объекта или препятствия.
	* Индекс строки и индекс символа определяют исходные координаты объекта или координаты препятствия.

Символы и соответствующие им препятствия и объекты игрового поля:
	* ** x ** — стена, препятствие
	* **!** — лава, препятствие
	* **@** — игрок, объект
	* ** o ** — монетка, объект
	* **=** — движущаяся горизонтально шаровая молния, объект
	* **|** — движущаяся вертикально шаровая молния, объект
	* ** v ** — огненный дождь, объект

> Обратите внимание, что тут слово «символ» означает букву, цифру или знак, которые используются в строках, а не тип данных`Symbol`.
*/

class LevelParser {
	
  /* Конструктор
	Принимает один аргумент — словарь движущихся объектов игрового поля, _объект_, ключами которого являются символы из текстового представления уровня, а значениями — конструкторы, с помощью которых можно создать новый объект.
  */
	
  constructor(dictionery = {}) { // dictionery - словарь движущихся объектов игрового поля
	this.dictionery = dictionery;	   
  }
	
  /* Метод `actorFromSymbol`
  Принимает символ, _строка_. Возвращает конструктор объекта по его символу, используя словарь. Если в словаре не нашлось ключа с таким символом, вернет `undefined`.
  */
	
  actorFromSymbol(symbol) {
	if (symbol && this.dictionery) {
	  return this.dictionery[symbol];
	}	 
  }
	
  /* Метод `obstacleFromSymbol`
  Аналогично принимает символ, _строка_. Возвращает строку, соответствующую символу препятствия. Если символу нет соответствующего препятствия, то вернет `undefined`.
  Вернет `wall`, если передать `x`.
  Вернет `lava`, если передать `!`.
  Вернет `undefined`, если передать любой другой символ.	
  */
	
  obstacleFromSymbol(symbol) {
	if (symbol === 'x') {
	  return 'wall';
	}
	if (symbol === `!`) {
	  return 'lava';
	}
  }
	
	/* Метод `createGrid`
	Принимает массив строк и преобразует его в массив массивов, в ячейках которого хранится либо строка, соответствующая препятствию, либо `undefined`.
	Движущиеся объекты не должны присутствовать на сетке.		*/
	
  createGrid(plan) {
	return plan.map(row => row.split('').map(symbol => this.obstacleFromSymbol(symbol)));
  }
	
	/*Метод `createActors`
	Принимает массив строк и преобразует его в массив движущихся объектов, используя для их создания классы из словаря.
	Количество движущихся объектов в результирующем массиве должно быть равно количеству символов объектов в массиве строк.
	Каждый объект должен быть создан с использованием вектора, определяющего его положение с учетом координат, полученных на основе индекса строки в массиве (Y) и индекса символа в строке (X).
	Для создания объекта должен быть использован класс из словаря, соответствующий символу. При этом, если этот класс не является наследником `Actor`, то такой символ игнорируется, и объект не создается.	*/
	
  createActors(plan) {
	return plan.reduce((prev, currY, y) => {
	  currY.split('').forEach((currX, x) => {
		const constructor = this.actorFromSymbol(currX);
		if (typeof constructor === 'function') {  // проверка символов для которых в словаре передана функция
		  const actor = new constructor(new Vector(x, y));
		  if (actor instanceof Actor) {    // проверка символов для которых в словаре передан конструктор типа Actor
			prev.push(actor);
		  }
		} 
	  });
	  return prev;    // вернет пустой массив, если не опред символы движущ.объектов
	}, []); // вернет пустой массив, если передан пустой план
  }
  	
  /* Метод `parse`
  Принимает массив строк, создает и возвращает игровое поле, заполненное препятствиями и движущимися объектами, полученными на основе символов и словаря  */
  
  parse(plan) {
	return new Level(this.createGrid(plan), this.createActors(plan));
  }  	
	
} // LevelParser

/* Шаровая молния
Класс `Fireball` станет прототипом для движущихся опасностей на игровом поле. Он должен наследовать весь функционал движущегося объекта `Actor` */

class Fireball extends Actor {
	
	/* Конструктор
	Принимает два аргумента: координаты, _объект_ `Vector` и скорость, тоже _объект_ `Vector`. Оба аргумента необязательные. По умолчанию создается объект с координатами `0:0` и скоростью `0:0`.
	Свойства
	Созданный объект должен иметь свойство `type` со значением `fireball`. Это свойство только для чтения.
	Также должен иметь размер `1:1` в свойстве `size`, _объект_ `Vector`.
	*/
	
  constructor(pos = new Vector(0, 0), speed = new Vector(0, 0)) {
	super(pos, new Vector(1, 1), speed)
  }
	
  get type() {
	return 'fireball';
  }
	
	/* Метод `getNextPosition`
	Создает и возвращает вектор `Vector` следующей позиции шаровой молнии. Это функция времени. И как в школьной задаче, новая позиция — это текущая позиция плюс скорость, умноженная на время. И так по каждой из осей.
	Принимает один аргумент, время, _число_. Аргумент необязательный, по умолчанию равен `1`.
	*/
	
  getNextPosition(time = 1) {
//	  return new Vector(this.pos.x + this.speed.x * time,
//						this.pos.y + this.speed.y * time);
	return this.pos.plus(this.speed.times(time));
  }
	
	/*Метод `handleObstacle`
	Обрабатывает столкновение молнии с препятствием. Не принимает аргументов. Ничего не возвращает.
	Меняет вектор скорости на противоположный. Если он был `5:5`, то после должен стать `-5:-5`.	
	*/
	
  handleObstacle() {
	this.speed = this.speed.times(-1);
  }
	
	/* Метод `act`
	Обновляет состояние движущегося объекта.
	Принимает два аргумента. Первый — время, _число_, второй — игровое поле, _объект_ `Level`.
	Метод ничего не возвращает. Но должен выполнить следующие действия:
	1. Получить следующую позицию, используя время.
	2. Выяснить, не пересечется ли в следующей позиции объект с каким-либо препятствием. Пересечения с другими движущимися объектами учитывать не нужно.
	3. Если нет, обновить текущую позицию объекта.
	4. Если объект пересекается с препятствием, то необходимо обработать это событие. При этом текущее положение остается прежним.
	*/
	
  act(time, level) {
	const nextPos = this.getNextPosition(time);
	if (level.obstacleAt(nextPos, this.size)) {
	  this.handleObstacle();
	} else {
	  this.pos = nextPos;
	}		
  }		
} // Fireball


/* Горизонтальная шаровая молния
Вам необходимо самостоятельно реализовать класс `HorizontalFireball`. Он будет представлять собой объект, который движется по горизонтали со скоростью `2` и при столкновении с препятствием движется в обратную сторону.
Конструктор должен принимать один аргумент — координаты текущего положения, _объект_ `Vector`. И создавать объект размером `1:1` и скоростью, равной `2` по оси X. */

class HorizontalFireball extends Fireball {
  constructor(pos = new Vector(0, 0)) {
	  super(pos, new Vector(2, 0));
  }
}

/* Вертикальная шаровая молния
Вам необходимо самостоятельно реализовать класс `VerticalFireball`. Он будет представлять собой объект, который движется по вертикали со скоростью `2` и при столкновении с препятствием движется в обратную сторону.
Конструктор должен принимать один аргумент: координаты текущего положения, _объект_ `Vector`. И создавать объект размером `1:1` и скоростью, равной `2` по оси Y. */

class VerticalFireball extends Fireball {
  constructor(pos = new Vector(0, 0)) {
	super(pos, new Vector(0, 2));	
  }
}

/* Огненный дождь
Вам необходимо самостоятельно реализовать класс `FireRain`. Он будет представлять собой объект, который движется по вертикали со скоростью `3` и при столкновении с препятствием начинает движение в том же направлении из исходного положения, которое задано при создании.
Конструктор должен принимать один аргумент — координаты текущего положения, _объект_ `Vector`. И создавать объект размером `1:1` и скоростью, равной `3` по оси Y. */

class FireRain extends Fireball {
  constructor(pos = new Vector(0, 0)) {
	super(pos, new Vector(0, 3));
	this.startPos = pos;  // движение в том же направлении из исходного положения
  }
  
  handleObstacle() {
	this.pos = this.startPos; // Вектор скорости не меняет своего направления при столкновении
  }
} // FireRain


/* Монета
Класс `Coin` реализует поведение монетки на игровом поле. 
Чтобы привлекать к себе внимание, монетки должны постоянно подпрыгивать в рамках своей ячейки. 
Класс должен наследовать весь функционал движущегося объекта `Actor`. */

class Coin extends Actor {
	
  /* Конструктор
  Принимает один аргумент — координаты положения на игровом поле, _объект_ `Vector`.
  Созданный объект должен иметь размер `0,6:0,6`. А его реальные координаты должны отличаться от тех, что переданы в конструктор, на вектор `0,2:0,1`.   */	
	
  constructor(pos = new Vector(0, 0)) {
	super(pos.plus(new Vector(0.2, 0.1)), new Vector(0.6, 0.6));
	this.springSpeed = 8;    // Скорость подпрыгивания
	this.springDist = 0.07;  // Радиус подпрыгивания
	this.spring = Math.random() * Math.PI * 2.0; // Фаза подпрыгивания
	this.startPos = this.pos;  
  }
	
  /* Свойства
  Свойство `type` созданного объекта должно иметь значение `coin`.
  Также объект должен иметь следующие свойства:
  * Скорость подпрыгивания, `springSpeed`, равная `8`;
  * Радиус подпрыгивания, `springDist`, равен `0.07`;
  * Фаза подпрыгивания, `spring`, случайное число от `0` до `2π`.   */
	
  get type() {
	  return 'coin';
  }	
	
  /* Метод `updateSpring`
  Обновляет фазу подпрыгивания. Это функция времени.
  Принимает один аргумент — время, _число_, по умолчанию `1`.
  Ничего не возвращает. 
  Обновляет текущую фазу `spring`, увеличив её на скорость `springSpeed`, умноженную на время.   */  
	
  updateSpring(time = 1) {
	this.spring += this.springSpeed * time;
  }
	
  /* Метод `getSpringVector`
  Создает и возвращает вектор подпрыгивания. Не принимает аргументов.
  Так как подпрыгивание происходит только по оси Y, то координата X вектора всегда равна нулю.
  Координата Y вектора равна синусу текущей фазы, умноженному на радиус.  
  */
	
  getSpringVector() {
	return new Vector(0, Math.sin(this.spring) * this.springDist);  
  }	
	
  /* Метод `getNextPosition`
  Обновляет текущую фазу, создает и возвращает вектор новой позиции монетки.
  Принимает один аргумент — время, _число_, по умолчанию `1`.
  Новый вектор равен базовому вектору положения, увеличенному на вектор подпрыгивания. Увеличивать нужно именно базовый вектор положения, который получен в конструкторе, а не текущий.  
  */	
	
  getNextPosition(time = 1) {
//	this.spring += this.springSpeed * time; 
	this.updateSpring(time);
	const newVector = this.getSpringVector();
	return this.startPos.plus(newVector);
  }

  /* Метод `act`
  Принимает один аргумент — время. Получает новую позицию объекта и задает её как текущую. Ничего не возвращает.
  */  
	
  act(time) {
  	this.pos = this.getNextPosition(time);
  }	
} // Coin


/* Игрок
Класс `Player` содержит базовый функционал движущегося объекта, который представляет игрока на игровом поле. Должен наследовать возможности `Actor`.
*/

class Player extends Actor {
  /* Конструктор
  Принимает один аргумент — координаты положения на игровом поле, _объект_ `Vector`.
  Созданный объект, реальное положение которого отличается от того, что передано в конструктор, на вектор `0:-0,5`. Имеет размер `0,8:1,5`. И скорость `0:0`.
  Свойства:  Имеет свойство `type`, равное `player`.
  */
  constructor(pos = new Vector(0, 0)) {
//	pos = pos.plus(new Vector(0, -0.5));
//	let size = new Vector(0.8, 1.5), speed = new Vector(0, 0);
//	super(pos, size, speed);
	super(pos.plus(new Vector(0, -0.5)), new Vector(0.8, 1.5), new Vector(0, 0));
  }
	
  get type() {
	return 'player';
  }	
}  // Player

 const actorDict = {
  '@': Player,
  'v': FireRain,
  'o': Coin,
  '=': HorizontalFireball,
  '|': VerticalFireball
};

//Функция `runLevel`
/* Инициализирует процесс регулярной отрисовки текущего состояния игрового поля и обработку событий клавиатуры.
Принимает два аргумента: уровень (объект класса `Level`) и конструктор объекта, отвечающего за отрисовку. В случае реализации игры в браузере вторым аргументом необходимо использовать класс `DOMDisplay`.
Функция возвращает промис, который разрешится статусом завершения игры, _строка_. С учетом реализации класса `Level` он может принимать значения `won` или `lost`.
После вызова такого кода в браузере будет отрисована схема уровня, движущиеся объекты будут перемещаться, и вы сможете управлять игроком с клавиатуры.
*/
//Пример использования:
//
//const schema = [
//  '         ',
//  '         ',
//  '    =    ',
//  '       o ',
//  '     !xxx',
//  ' @       ',
//  'xxx!     ',
//  '         '
//];

//const parser = new LevelParser(actorDict);
//const level = parser.parse(schema);
//runLevel(level, DOMDisplay)
//  .then(status => console.log(`Игрок ${status}`));

// Функция `runGame`
/* Инициализирует процесс прохождения игры, состоящей из последовательного прохождения нескольких уровней.
Принимает три аргумента: список схем уровней, _массив_, каждый элемент которого — схема (массив строк); парсер схем, _объект_ `LevelParser`, и конструктор объекта, отвечающего за отрисовку. В случае реализации игры в браузере третьим аргументом необходимо использовать класс `DOMDisplay`.
Возвращает промис, который разрешится, когда пользователь пройдет все уровни.
Запустит игру из двух уровней, которые необходимо будет пройти последовательно.
Пример использования:
*/

//const schemas = [
//  [
//    '         ',
//    '         ',
//    '    =    ',
//    '       o ',
//    '     !xxx',
//    ' @       ',
//    'xxx!     ',
//    '         '
//  ],
//  [
//    '      v  ',
//    '    v    ',
//    '  v      ',
//    '        o',
//    '        x',
//    '@   x    ',
//    'x        ',
//    '         '
//  ]
//];
//
//const parser = new LevelParser(actorDict);
//runGame(schemas, parser, DOMDisplay)
//  .then(() => console.log('Вы выиграли приз!'));

//Функция `loadLevels`
/* Загружает коллекцию уровней. Не принимает аргументов.
Возвращает промис, который разрешится JSON-строкой, в которой закодирован массив схем уровней.
*/

const parser = new LevelParser(actorDict);
loadLevels()
  .then(result => {
	runGame(JSON.parse(result), parser, DOMDisplay)
      .then(() => console.log('Вы выиграли приз!'));
})